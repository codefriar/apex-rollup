/**
 * Repository pattern implementation providing a fluent API for database operations within the Rollup
 * framework. Abstracts SOQL execution, bind variable management, and security context handling (USER vs SYSTEM mode).
 * This class solves the complexity of managing dynamic queries with bind variables while respecting security boundaries
 * and providing consistent logging across all database operations.
 *
 * Key design decisions:
 * - Fluent builder pattern enables readable query construction and method chaining
 * - Custom RunAsMode enum avoids serialization failures with System.AccessLevel in async contexts
 * - ToStringObject implementation enables meaningful debug output of query state
 * - Centralized query execution ensures consistent logging and error handling
 *
 * @see RollupQueryBuilder For query string construction
 * @see RollupLogger For operation logging
 * @group Apex Rollup
 */
public without sharing class RollupRepository implements RollupLogger.ToStringObject {
  /**
   * Sentinel value returned by getCount() when count queries fail (e.g., due to polymorphic field
   * limitations). Consumers should check for this value and handle appropriately rather than assuming valid counts.
   */
  public static final Integer SENTINEL_COUNT_VALUE = -1;

  @TestVisible
  private final Args args = new Args();
  private final RunAsMode localRunAsMode;
  private Boolean shouldLog = true;

  private transient System.AccessLevel accessLevel {
    get {
      this.accessLevel = this.accessLevel ?? this.transformPermissionLevel(this.localRunAsMode);
      return this.accessLevel;
    }
    set;
  }

  /**
   * Internal container for query state including the SOQL string and bind variable map.
   * Encapsulates query parameters to enable clean serialization and state management.
   */
  private class Args {
    public final Map<String, Object> bindVars = new Map<String, Object>();
    public String query;
  }

  /**
   * Serialization-safe alternative to System.AccessLevel for controlling CRUD/FLS enforcement.
   * System.AccessLevel cannot be reliably serialized/deserialized in Queueable/Batchable contexts - equality
   * checks against USER_MODE or SYSTEM_MODE fail after serialization. This enum provides identical functionality
   * with reliable behavior in async execution contexts.
   */
  public enum RunAsMode {
    /** @description Bypasses CRUD/FLS checks, equivalent to System.AccessLevel.SYSTEM_MODE */
    SYSTEM_LEVEL,
    /** @description Enforces CRUD/FLS based on running user, equivalent to System.AccessLevel.USER_MODE */
    USER
  }

  /**
   * Constructs a repository with the specified security context. The run mode determines whether
   * queries enforce the running user's CRUD/FLS permissions or bypass them for system-level operations.
   * @param localRunAsMode The security context for all queries executed by this repository instance
   */
  public RollupRepository(RunAsMode localRunAsMode) {
    this.localRunAsMode = localRunAsMode;
    this.accessLevel = this.transformPermissionLevel(localRunAsMode);
  }

  /**
   * Sets the SOQL query string for this repository. Part of the fluent builder pattern.
   * @param query The SOQL query string (may contain bind variable placeholders like :objIds)
   * @return This repository instance for method chaining
   */
  public RollupRepository setQuery(String query) {
    this.args.query = query;
    return this;
  }

  /**
   * Sets the default bind variable value using the standard BIND_VAR key. Convenience method
   * for queries using the standard 'objIds' bind variable generated by RollupQueryBuilder.
   * @param value The value to bind (typically a Set or List of Ids)
   * @return This repository instance for method chaining
   */
  public RollupRepository setArg(Object value) {
    return this.setArg(RollupQueryBuilder.BIND_VAR, value);
  }

  /**
   * Sets a named bind variable value for the query. Supports multiple bind variables
   * in complex queries with custom variable names.
   * @param key The bind variable name (without the colon prefix)
   * @param value The value to bind to the variable
   * @return This repository instance for method chaining
   */
  public RollupRepository setArg(String key, Object value) {
    this.args.bindVars.put(key, value);
    return this;
  }

  /**
   * Returns a Database.Cursor for efficient processing of large result sets. Cursors enable
   * row-by-row iteration without loading all records into memory, ideal for batch processing scenarios.
   * @return A cursor positioned at the start of the result set
   */
  public Database.Cursor getCursor() {
    this.createQueryLog('Getting cursor');
    return Database.getCursorWithBinds(this.args.query, this.args.bindVars, this.accessLevel);
  }

  /**
   * Returns a QueryLocator for use with Database.Batchable implementations. QueryLocators
   * bypass the standard 50,000 row SOQL limit, enabling batch jobs to process up to 50 million records.
   * @return A QueryLocator that can be passed to Database.executeBatch()
   */
  public Database.QueryLocator getLocator() {
    this.createQueryLog('Getting query locator');
    return Database.getQueryLocatorWithBinds(this.args.query, this.args.bindVars, this.accessLevel);
  }

  /**
   * Executes the configured query and returns all matching records. Subject to standard
   * SOQL limits (50,000 rows). For larger datasets, use getCursor() or getLocator() instead.
   * @return List of matching SObject records
   */
  public List<SObject> get() {
    this.createQueryLog('Querying...');
    return Database.queryWithBinds(this.args.query, this.args.bindVars, this.accessLevel);
  }

  /**
   * Executes a count query version of the configured query. Automatically transforms the
   * SELECT clause to Count() and handles ALL ROWS removal (not compatible with count queries). Returns
   * SENTINEL_COUNT_VALUE (-1) if the count query fails, which can occur with polymorphic field queries
   * that don't support aggregation.
   * @return The record count, or SENTINEL_COUNT_VALUE if the count query is invalid
   */
  public Integer getCount() {
    String originalQuery = this.args.query;
    if (this.args.query.contains(RollupQueryBuilder.ALL_ROWS)) {
      this.args.query = this.args.query.replace(RollupQueryBuilder.ALL_ROWS, '');
    }
    this.args.query = this.args.query.replaceFirst('SELECT.+\n', 'SELECT Count()\n');
    this.createQueryLog('Getting count');

    Integer countAmount;
    try {
      countAmount = Database.countQueryWithBinds(this.args.query, this.args.bindVars, this.accessLevel);
    } catch (Exception ex) {
      RollupLogger.Instance.log('an error occurred while trying to get count query', ex, System.LoggingLevel.WARN);
      // not all count queries are valid, particularly those with polymorphic fields referencing parent fields
      // return a sentinel value instead, to be checked for downstream
      countAmount = SENTINEL_COUNT_VALUE;
    }
    this.createQueryLog('Returned amount: ' + countAmount);
    this.args.query = originalQuery;
    return countAmount;
  }

  /**
   * Returns a debug-friendly representation of the repository state including the query string,
   * bind variable keys, and access level. Implements ToStringObject for enhanced logging output.
   * @return Formatted string containing query details for debugging
   */
  public override String toString() {
    return this.args.query + '\nBind keys: ' + this.args.bindVars.keySet() + '\nAccess level: ' + this.localRunAsMode;
  }

  /**
   * Retrieves all active, non-disabled Rollup__mdt records with their related RollupOrderBy__mdt
   * children and RollupGrouping__mdt parent. Performs field value transformation to resolve Entity Definition
   * lookups to their qualified API names (e.g., 'Account' from CalcItem__r.QualifiedApiName). Supports the
   * ShouldOptimizeCMDTQueries__c optimization flag which skips Entity Definition joins when text fields are
   * already populated, reducing query complexity in large metadata environments.
   * @return List of fully-hydrated Rollup__mdt records ready for rollup processing
   */
  @SuppressWarnings('PMD.ApexCRUDViolation')
  public static List<Rollup__mdt> getRollupMetadata() {
    List<Rollup__mdt> matchingMetadata;

    List<String> selectFields = new List<String>{
      '(SELECT Id, DeveloperName, FieldName__c, NullSortOrder__c, Ranking__c, ShouldOverridePicklistOrdering__c, SortOrder__c FROM RollupOrderBys__r)',
      'RollupGrouping__r.Id',
      'RollupGrouping__r.RollupOperation__c',
      Rollup__mdt.CalcItemText__c.toString(),
      Rollup__mdt.CalcItemWhereClause__c.toString(),
      Rollup__mdt.ChangedFieldsOnCalcItem__c.toString(),
      Rollup__mdt.ConcatDelimiter__c.toString(),
      Rollup__mdt.CurrencyFieldMapping__c.toString(),
      Rollup__mdt.DeveloperName.toString(),
      Rollup__mdt.FullRecalculationDefaultNumberValue__c.toString(),
      Rollup__mdt.FullRecalculationDefaultStringValue__c.toString(),
      Rollup__mdt.GrandparentRelationshipFieldPath__c.toString(),
      Rollup__mdt.GroupByFields__c.toString(),
      Rollup__mdt.GroupByRowEndDelimiter__c.toString(),
      Rollup__mdt.GroupByRowStartDelimiter__c.toString(),
      Rollup__mdt.IsDisabled__c.toString(),
      Rollup__mdt.IsDistinct__c.toString(),
      Rollup__mdt.IsFullRecordSet__c.toString(),
      Rollup__mdt.IsRollupStartedFromParent__c.toString(),
      Rollup__mdt.IsTableFormatted__c.toString(),
      Rollup__mdt.LimitAmount__c.toString(),
      Rollup__mdt.LookupFieldOnCalcItemText__c.toString(),
      Rollup__mdt.LookupFieldOnLookupObjectText__c.toString(),
      Rollup__mdt.LookupObjectText__c.toString(),
      Rollup__mdt.MasterLabel.toString(),
      Rollup__mdt.OneToManyGrandparentFields__c.toString(),
      Rollup__mdt.OrderByFirstLast__c.toString(),
      Rollup__mdt.RollupControl__c.toString(),
      Rollup__mdt.RollupFieldOnCalcItemText__c.toString(),
      Rollup__mdt.RollupFieldOnLookupObjectText__c.toString(),
      Rollup__mdt.RollupOperation__c.toString(),
      Rollup__mdt.RollupToUltimateParent__c.toString(),
      Rollup__mdt.SharingMode__c.toString(),
      Rollup__mdt.ShouldRunWithoutCustomSettingEnabled__c.toString(),
      Rollup__mdt.SplitConcatDelimiterOnCalcItem__c.toString(),
      Rollup__mdt.UltimateParentLookupText__c.toString()
    };

    if (Rollup.getDefaultControl()?.ShouldOptimizeCMDTQueries__c != true) {
      selectFields.addAll(
        new List<String>{
          'CalcItem__r.QualifiedApiName',
          'LookupFieldOnCalcItem__r.QualifiedApiName',
          'LookupFieldOnLookupObject__r.QualifiedApiName',
          'LookupObject__r.QualifiedApiName',
          'RollupFieldOnCalcItem__r.QualifiedApiName',
          'RollupFieldOnLookupObject__r.QualifiedApiName',
          'UltimateParentLookup__r.QualifiedApiName'
        }
      );
    }

    matchingMetadata = new RollupRepository(RollupRepository.RunAsMode.SYSTEM_LEVEL)
      .setQuery('SELECT ' + String.join(selectFields, ',\n') + '\nFROM Rollup__mdt\nWHERE RollupControl__r.ShouldAbortRun__c = FALSE AND IsDisabled__c = FALSE')
      .setShouldLog(false)
      .get();

    // do the transforms for standard query
    for (Rollup__mdt meta : matchingMetadata) {
      meta.CalcItem__c = meta.CalcItemText__c ?? meta.CalcItem__r.QualifiedApiName;
      meta.LookupFieldOnCalcItem__c = meta.LookupFieldOnCalcItemText__c ?? meta.LookupFieldOnCalcItem__r.QualifiedApiName;
      meta.LookupFieldOnLookupObject__c = meta.LookupFieldOnLookupObjectText__c ?? meta.LookupFieldOnLookupObject__r.QualifiedApiName;
      meta.LookupObject__c = meta.LookupObjectText__c ?? meta.LookupObject__r.QualifiedApiName;
      meta.RollupFieldOnCalcItem__c = meta.RollupFieldOnCalcItemText__c ?? meta.RollupFieldOnCalcItem__r.QualifiedApiName;
      meta.RollupFieldOnLookupObject__c = meta.RollupFieldOnLookupObjectText__c ?? meta.RollupFieldOnLookupObject__r.QualifiedApiName;
      meta.UltimateParentLookup__c = meta.RollupToUltimateParent__c ? meta.UltimateParentLookupText__c ?? meta.UltimateParentLookup__r.QualifiedApiName : null;

      meta.GroupByRowEndDelimiter__c = meta.GroupByRowEndDelimiter__c?.unescapeJava();
      meta.GroupByRowStartDelimiter__c = meta.GroupByRowStartDelimiter__c?.unescapeJava();
      meta.SharingMode__c = meta.SharingMode__c ?? RollupMetaPicklists.SharingMode.SystemLevel;
    }

    return matchingMetadata;
  }

  private void createQueryLog(String message) {
    if (this.shouldLog) {
      RollupLogger.Instance.Log(message, this, System.LoggingLevel.DEBUG);
    }
  }

  private RollupRepository setShouldLog(Boolean shouldLog) {
    this.shouldLog = shouldLog;
    return this;
  }

  private System.AccessLevel transformPermissionLevel(RunAsMode currentRunAs) {
    return currentRunAs == RunAsMode.USER ? System.AccessLevel.USER_MODE : System.AccessLevel.SYSTEM_MODE;
  }

  /**
   * Comparator for sorting RollupOrderBy__mdt records by their Ranking__c field (primary)
   * and DeveloperName (secondary tiebreaker). Used to establish deterministic ordering of ORDER BY clauses
   * when multiple RollupOrderBy__mdt records exist for a single Rollup__mdt configuration. Implements
   * multi-field comparison to ensure consistent sort behavior across transactions.
   */
  public class OrderBySorter implements System.Comparator<RollupOrderBy__mdt> {
    private final List<Schema.SObjectField> sortFields = new List<Schema.SObjectField>{ RollupOrderBy__mdt.Ranking__c, RollupOrderBy__mdt.DeveloperName };

    /**
     * Compares two RollupOrderBy__mdt records for sorting. First compares by Ranking__c,
     * then by DeveloperName if rankings are equal. This ensures predictable ORDER BY clause construction.
     * @param first The first record to compare
     * @param second The second record to compare
     * @return Negative if first < second, positive if first > second, zero if equal
     */
    public Integer compare(RollupOrderBy__mdt first, RollupOrderBy__mdt second) {
      Integer returnValue = 0;
      List<Schema.SObjectField> localSortFields = new List<Schema.SObjectField>(this.sortFields);
      while (returnValue == 0 && localSortFields.isEmpty() == false) {
        Schema.SObjectField field = localSortFields.remove(0);
        Object firstSortValue = first.get(field);
        Object secondSortValue = second.get(field);

        if (firstSortValue instanceof Decimal) {
          returnValue = this.getDecimalSortedValue((Decimal) firstSortValue, (Decimal) secondSortValue);
        } else if (firstSortValue instanceof String) {
          returnValue = ((String) firstSortValue).compareTo((String) secondSortValue);
        }
      }
      return returnValue;
    }

    private Integer getDecimalSortedValue(Decimal first, Decimal second) {
      Integer returnValue = 0;
      if (first > second) {
        returnValue = 1;
      } else if (first < second) {
        returnValue = -1;
      }
      return returnValue;
    }
  }
}
